# CashFree Payment

- Get the app id and the secret key generated by CashFree
- Create an instance of CashFree class using the id and key
- Keep the key secret in the env file
- Create an Orders table
- Establish relationship between Order and User tables(One to Many)
- Generate order id(generated by the developer)
- Provide all the order details
- The CashFree instance uses these details to create an order
- After the order is created, it returns a payment session id
- Using the payment session id, we are redirecting the user to the checkout page
- When the redirect url is hit, the payment status is being verified
- Update the Orders table accordingly
- Also update the User table

# Leaderboard

- Make a get request to '/premium/leaderboard' route
- Get all the users along with their total expenses
- Sort the users based on their total expenses
- Rank the users
- Highlight the current user

# Implementing AI

- generate google ai api key
- user adds expense, selects 'other' in category
- ai will read the expense description and determine the category

# Forgot Password

- use SendInBlue mailing service
- display a form where the user can insert his registered email
- create table to store all the requests for forgot password
- store a unique id, the user id and a isActive field to check whether the reset password link has been used before or not
- create the reset password link using the unique id for each request
- reset password link is sent to the email the user entered
- when user clicks link, it opens a page that immediately calls a backend api
- the backend api checks whether the reset link is valid or not
- if the link is valid, show the reset password form else show error
- when the user submits the reset password form another backend api is called to change the password in the database.

# Pagination

## Overview

- this app uses server side pagination to efficiently handle large datasets and improve performance

## Strategy

- backend handles the pagination
- frontend controls pagination with query parameters
- data is fetched page-wise with a limit per page

## API contract

**Request Parameters**

- page number: current page number (1 based)
- limit : number of expenses per page. it is dynamic (5,10,15,20)

**Response Structure**

- result: an array of expenses for the current page
- hasNextPage : boolean value to indicate whether a next page exists or not

## Frontend behaviour

- the pagination section is hidden when there are no expenses
- pagination controls are disabled when there are no next and prev pages
- data is refetched on page change

## Backend functionality

- The backend sanitizes incoming pagination parameters to ensure data consistency
- uses page and limit to fetch only the requested data from the database
- it is fetching one expense data more than the limit so as to check the whether any more page exists or not
- if the number of expenses fetched is more than the limit then another page of expenses exist
- using hasNextPage flag to notify the frontend whether next page exists or not
- page numbers less than 1 are clamped to 1
- invalid or missing page values default to 1

# To-do

- When the user opens the website he will be first redirected to the login page
- how to decide the expiry of the jwt token, so that after sometime the user has to login again
- logout button
- Validate phone number from backend
- Payment status verification using webhook
- Edit button functionality
- how to check when token validity expires
- how to redirect user directly to login page when token expires
- check forgot password code

# Colors

- primary: #29756F
- #348781
- linear-gradient(2deg,rgba(73, 144, 139, 1) 100%, rgba(97, 167, 162, 1) 100%);
- #FF6B6B
- #F7B32B
- #20373F
- #3BC0BF
- #274C55
